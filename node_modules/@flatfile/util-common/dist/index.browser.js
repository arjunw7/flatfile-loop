import { FlatfileClient } from '@flatfile/api';
import { CrossEnvConfig } from '@flatfile/cross-env-config';
import y from 'cross-fetch';

async function u(r,e){let t=[];for(let o=0;o<r;o++){let s=await e(o);t.push(s);}return t}var C=new FlatfileClient,l=1e4;async function g(r,e={}){let t=new URLSearchParams;t.set("pageNumber",String(e.pageNumber??1)),t.set("pageSize",String(e.pageSize??l)),Object.entries(e).forEach(([i,c])=>{c!==void 0&&(Array.isArray(c)?c.map(p=>t.append(i,String(p))):t.set(i,String(c)));});let{baseUrl:o,token:s}=b(),a=`${o}/v1/sheets/${r}/records?${t}`,n=await y(a,{method:"GET",headers:{Authorization:`Bearer ${s}`,"Content-Type":"application/json"}});if(!n.ok)throw new Error(`Reading ${e.pageNumber??1} of ${r} failed.`);try{return (await n.json()).data?.records??[]}catch(i){return console.log(i),[]}}async function w(r){let{data:{counts:e}}=await C.sheets.getRecordCounts(r);return e.total}async function H(r,e,t={}){let o=t.pageSize??l,s=await w(r),a=Math.ceil(s/o)||1,n=[];for(let i=1;i<=a;i++)try{let c=await g(r,{...t,pageSize:o,pageNumber:i});c.forEach(f=>Object.values(f.values).forEach(h=>delete h.updatedAt));let p=await e(c,i,a);p!=null&&n.push(p);}catch(c){console.error(c);}return n.length?n:void 0}async function _(r,e){let{baseUrl:t,token:o}=b(),s=await y(`${t}/v1/sheets/${r}/records`,{method:"POST",headers:{Authorization:`Bearer ${o}`,"Content-Type":"application/json","x-force-hooks":"true"},body:JSON.stringify(e)});if(!s.ok)throw console.log(await s?.text()),new Error("Creating records failed.");return (await s.json()).data.commitId}async function L(r,e){let{baseUrl:t,token:o}=b(),s=await y(`${t}/v1/sheets/${r}/records`,{method:"PUT",headers:{Authorization:`Bearer ${o}`,"Content-Type":"application/json","x-force-hooks":"true"},body:JSON.stringify(e)});if(s.status===304)return "not-modified";if(!s.ok)throw console.log(await s?.text()),new Error("Updating records failed.");return (await s.json()).data.commitId}async function P(r,e,t){let o=e.length,s=Math.ceil(o/l);await u(s,async a=>{let n=a*l,i=n+l<=e.length?n+l:e.length;return await t?.((a+1)/s,a+1,s).catch(console.log),L(r,e.slice(a*l,i))});}async function A(r,e,t){let o=e.length,s=Math.ceil(o/l);await u(s,async a=>{let n=a*l,i=n+l<=e.length?n+l:e.length;return await t?.((a+1)/s,a+1,s).catch(console.log),_(r,e.slice(a*l,i))});}function b(){let r=CrossEnvConfig.get("AGENT_INTERNAL_URL")||CrossEnvConfig.get("FLATFILE_API_URL")||"https://platform.flatfile.com/api",e=CrossEnvConfig.get("FLATFILE_BEARER_TOKEN")||CrossEnvConfig.get("FLATFILE_API_KEY");return {baseUrl:r,token:e}}async function V(r,e,t={},o){let{chunkSize:s=1e4,parallel:a=1,debug:n=!1}=t,i=$(r,s);n&&console.log(`${i.length} chunks to be processed`);let c=new Map;async function p(d,m){n&&console.log(`Thread ${m} processing chunk ${d}`);let k=await e(i[d],o);c.set(d,k);}let f=0;async function h(d){for(;f<i.length;){let m=f++;await p(m,d);}}let E=Array.from({length:a},(d,m)=>h(m));return await Promise.all(E),n&&console.log("All chunks processed"),Array.from(c.values())}function $(r,e){return e<=0?[]:Array.from({length:Math.ceil(r.length/e)},(t,o)=>r.slice(o*e,o*e+e))}var T=new FlatfileClient;async function D(r,e){try{let{data:t}=await T.sheets.get(r);await T.jobs.create({type:"workbook",operation:"delete-records",trigger:"immediate",source:t.workbookId,config:{...e,sheet:r}});}catch(t){throw console.error("Error deleting records:",t),new Error("Error deleting records")}}var S=(r,e,t="log")=>{let o={log:"INFO",warn:"WARN",error:"FATAL"};console[t](`[${r}]:[${o[t]}] ${e}`);},W=(r,e)=>{S(r,e);},K=(r,e)=>{S(r,e,"warn");},Z=(r,e)=>{S(r,e,"error");};var Q=r=>r.trim().replace(/[^\w\s-]/g,"").replace(/[\s_-]+/g,"-").replace(/^-+|-+$/g,"");var F=2e3,v=class r{static async getAllRecords(e,t={},o){let s=await w(e),a=t.pageSize||F,n=Math.ceil(s/a);return (await u(n,async c=>(await o?.((c+1)/n,c+1,n).catch(console.log),(await g(e,{...t,pageNumber:c+1,pageSize:a})).map(r.toSimpleRecord)))).flat(1)}static async getAllRecordsSeries(e,t={}){let o=t.pageSize||F,s=[],a=1;for(;;){let n=await g(e,{...t,pageSize:o,pageNumber:a});if(s.push(n.map(r.toSimpleRecord)),a+=1,n.length<o)break}return s.flat(1)}static async findRecordsLimit(e,t,o=100){let s=await g(e,{...t,pageSize:o,pageNumber:1});return Array.isArray(s)?s.map(r.toSimpleRecord):[]}static toRecordValues(e){return Object.fromEntries(Object.entries(e).filter(([t])=>t!=="_id"&&t!=="_metadata").map(([t,o])=>[t,{value:o}]))}static toStandardRecord(e){return {id:e._id,metadata:e._metadata,values:r.toRecordValues(e)}}static toSimpleRecord(e){let t=Object.fromEntries(Object.entries(e.values).map(([o,s])=>[o,s.value]));return t._id=e.id,t._metadata=e.metadata,t}static updateAllRecords(e,t,o){return P(e,t.map(r.toStandardRecord),o)}static async createAllRecords(e,t,o){await A(e,t.map(r.toRecordValues),o);}};

export { v as Simplified, V as asyncBatch, $ as chunkify, A as createAllRecords, _ as createRecords, D as deleteRecords, g as getRecordsRaw, w as getSheetLength, S as log, Z as logError, W as logInfo, K as logWarn, H as processRecords, Q as slugify, P as updateAllRecords, L as updateRecords };
//# sourceMappingURL=index.browser.js.map
//# sourceMappingURL=index.browser.js.map