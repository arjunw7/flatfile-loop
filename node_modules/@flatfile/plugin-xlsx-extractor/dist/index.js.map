{"version":3,"sources":["../src/header.detection.ts","../src/utils.ts","../src/parser.ts","../src/index.ts"],"names":["ROWS_TO_SEARCH_FOR_HEADER","indexToLetters","index","letters","result","headersToLetters","headers","_","Headerizer","options","ExplicitHeaders","SpecificRows","DataRowAndSubHeaderDetection","OriginalDetector","countNonEmptyCells","row","cell","likelyContainsData","dataStream","currentRow","skip","header","detector","stream","encoding","callback","resolve","reject","error","maxRow","i","rows","previousRow","fuzzyHeader","fuzzySkip","word","prependNonUniqueHeaderColumns","record","counts","key","value","newValue","cleanValue","parseBuffer","buffer","workbook","e","sheetNames","processedSheets","sheetName","sheet","processedSheet","convertSheet","rawNumbers","raw","headerDetectionOptions","headerSelectionEnabled","skipEmptyLines","debug","extractValues","data","headerizer","headerStream","Readable","headerKey","columnKeys","excelHeader","keys","isNullOrWhitespace","mapValues","mapKeys","metadata","ExcelExtractor","Extractor","excelParser","xlsxExtractorPlugin"],"mappings":"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","file":"index.js","sourcesContent":["import stream from 'stream'\n\nexport const ROWS_TO_SEARCH_FOR_HEADER = 10\n\ninterface DefaultOptions {\n  algorithm: 'default'\n  rowsToSearch?: number\n}\n\ninterface ExplicitHeadersOptions {\n  algorithm: 'explicitHeaders'\n  headers: string[]\n  skip?: number\n}\n\ninterface SpecificRowsOptions {\n  algorithm: 'specificRows'\n  rowNumbers: number[]\n  skip?: number\n}\n\ninterface DataRowAndSubHeaderDetectionOptions {\n  algorithm: 'dataRowAndSubHeaderDetection'\n  rowsToSearch?: number\n}\n\ninterface NewfangledOptions {\n  algorithm: 'newfangled'\n}\n\nexport type GetHeadersOptions =\n  | DefaultOptions\n  | ExplicitHeadersOptions\n  | SpecificRowsOptions\n  | DataRowAndSubHeaderDetectionOptions\n  | NewfangledOptions\n\ninterface GetHeadersResult {\n  header: string[]\n  skip: number\n  letters: string[]\n}\n\nexport const indexToLetters = (index: number): string => {\n  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let result = ''\n\n  while (index >= 0) {\n    result = letters[index % 26] + result\n    index = Math.floor(index / 26) - 1\n  }\n\n  return result\n}\n\nexport const headersToLetters = (headers: string[]): string[] => {\n  return headers.map((_, index) => indexToLetters(index))\n}\n\n// Takes a datastream (representing a CSV) and returns the header row and the number of rows to skip\nexport abstract class Headerizer {\n  constructor() {}\n  abstract getHeaders(dataStream: stream.Readable): Promise<GetHeadersResult>\n\n  static create(options: GetHeadersOptions): Headerizer {\n    switch (options.algorithm) {\n      case 'explicitHeaders':\n        return new ExplicitHeaders(options)\n      case 'specificRows':\n        return new SpecificRows(options)\n      case 'dataRowAndSubHeaderDetection':\n        return new DataRowAndSubHeaderDetection(options)\n      case 'newfangled':\n        throw new Error('Not implemented')\n      default:\n        return new OriginalDetector(options)\n    }\n  }\n}\n\nexport const countNonEmptyCells = (row: string[]): number => {\n  return row.filter((cell) => cell !== null && `${cell}`.trim() !== '').length\n}\n\nexport const likelyContainsData = (row: string[]): boolean => {\n  return row.some(\n    (cell) =>\n      cell === null ||\n      cell.trim() === '' ||\n      !isNaN(Number(cell.trim())) ||\n      cell.trim().toLowerCase() === 'true' ||\n      cell.trim().toLowerCase() === 'false'\n  )\n}\n\n// This is the original / default implementation of detectHeader.\n// It looks at the first `rowsToSearch` rows and takes the row\n// with the most non-empty cells as the header, preferring the earliest\n// such row in the case of a tie.\nclass OriginalDetector extends Headerizer {\n  private rowsToSearch: number\n\n  constructor(private options: DefaultOptions) {\n    super()\n    this.rowsToSearch = options.rowsToSearch || ROWS_TO_SEARCH_FOR_HEADER\n  }\n\n  async getHeaders(dataStream: stream.Readable): Promise<GetHeadersResult> {\n    let currentRow = 0\n    let skip = 0\n    let header: string[] = []\n    let letters: string[] = []\n\n    // This is the original implementation of detectHeader\n    const detector = new stream.Writable({\n      objectMode: true,\n      write: (row, encoding, callback) => {\n        currentRow++\n        if (currentRow >= this.rowsToSearch) {\n          dataStream.destroy()\n        }\n        if (countNonEmptyCells(row) > countNonEmptyCells(header)) {\n          header = row\n          skip = currentRow\n          letters = headersToLetters(header)\n        }\n        callback()\n      },\n    })\n\n    dataStream.pipe(detector, { end: true })\n\n    return new Promise((resolve, reject) => {\n      detector.on('finish', () => {\n        resolve({ header, skip, letters })\n      })\n      dataStream.on('close', () => {\n        resolve({ header, skip, letters })\n      })\n      dataStream.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n}\n\n// This implementation simply returns an explicit list of headers\n// it was provided with.\nclass ExplicitHeaders extends Headerizer {\n  headers: string[]\n  constructor(private readonly options: ExplicitHeadersOptions) {\n    super()\n\n    if (!options.headers || options.headers.length === 0) {\n      throw new Error('ExplicitHeaders requires at least one header')\n    }\n  }\n\n  async getHeaders(dataStream: stream.Readable): Promise<GetHeadersResult> {\n    const letters = headersToLetters(this.options.headers)\n    return {\n      header: this.options.headers,\n      skip: this.options.skip || 0,\n      letters,\n    }\n  }\n}\n\n// This implementation looks at specific rows and combines them into a single header.\n// For example, if you knew that the header was in the third row, you could pass it\n// { rowNumbers: [2] }\nclass SpecificRows extends Headerizer {\n  constructor(private readonly options: SpecificRowsOptions) {\n    super()\n\n    if (!options.rowNumbers || options.rowNumbers.length === 0) {\n      throw new Error('SpecificRows requires at least one row number')\n    }\n  }\n\n  async getHeaders(dataStream: stream.Readable): Promise<GetHeadersResult> {\n    let currentRow = 0\n    let maxRow = Math.max(...this.options.rowNumbers)\n    let header: string[] = []\n    let letters: string[] = []\n\n    const detector = new stream.Writable({\n      objectMode: true,\n      write: (row, encoding, callback) => {\n        if (currentRow > maxRow) {\n          dataStream.destroy()\n        } else if (this.options.rowNumbers.includes(currentRow)) {\n          if (header.length === 0) {\n            // This is the first header row we've seen, so just remember it\n            header = row\n            letters = headersToLetters(header)\n          } else {\n            for (let i = 0; i < header.length; i++) {\n              if (header[i] === '') {\n                header[i] = row[i].trim()\n              } else {\n                header[i] = `${header[i].trim()} ${row[i].trim()}`\n              }\n              letters[i] = indexToLetters(i)\n            }\n          }\n        }\n        currentRow++\n        callback()\n      },\n    })\n\n    dataStream.pipe(detector, { end: true })\n\n    // If we have an explicit skip, use it, otherwise skip past the last header row\n    const skip = this.options.skip ?? maxRow + 1\n\n    // TODO: this logic is duplicated, factor it out?\n    return new Promise((resolve, reject) => {\n      detector.on('finish', () => {\n        resolve({ header, skip, letters })\n      })\n      dataStream.on('close', () => {\n        resolve({ header, skip, letters })\n      })\n      dataStream.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n}\n\n// This implementation attempts to detect the first data row and select the previous\n// row as the header. If the data row cannot be detected due to all of the sample\n// rows being full and not castable to a number or boolean type, it also will attempt\n// to detect a sub header row by checking following rows after a header is detected\n// for significant fuzzy matching. If over half of the fields in a possible sub header\n// row fuzzy match with the originally detected header row, the sub header row becomes\n// the new header.\nclass DataRowAndSubHeaderDetection extends Headerizer {\n  private rowsToSearch: number\n\n  constructor(private options: DataRowAndSubHeaderDetectionOptions) {\n    super()\n    this.rowsToSearch = options.rowsToSearch || ROWS_TO_SEARCH_FOR_HEADER\n  }\n\n  async getHeaders(dataStream: stream.Readable): Promise<GetHeadersResult> {\n    let currentRow = 0\n    let skip = 0\n    let header: string[] = []\n    const rows: string[][] = []\n    let letters: string[] = []\n\n    // This is the original implementation of detectHeader\n    const detector = new stream.Writable({\n      objectMode: true,\n      write: (row, encoding, callback) => {\n        currentRow++\n        if (currentRow >= this.rowsToSearch) {\n          dataStream.destroy()\n        }\n        rows.push(row)\n\n        if (countNonEmptyCells(row) > countNonEmptyCells(header)) {\n          header = row\n          skip = currentRow\n          letters = headersToLetters(header)\n        }\n        // check if row has numeric, boolean, or empty values\n        if (likelyContainsData(row)) {\n          // if so, check if the row before is as long as the current header and only contains strings\n          const previousRow = rows[rows.length - 2]\n          if (\n            previousRow &&\n            countNonEmptyCells(header) === countNonEmptyCells(previousRow) &&\n            !likelyContainsData(previousRow)\n          ) {\n            // if it is, make it the header\n            header = previousRow\n            skip = currentRow - 1\n            letters = headersToLetters(header)\n          }\n        }\n\n        callback()\n      },\n    })\n\n    dataStream.pipe(detector, { end: true })\n\n    await new Promise<void>((resolve, reject) => {\n      detector.on('finish', () => {\n        resolve()\n      })\n      dataStream.on('close', () => {\n        resolve()\n      })\n      dataStream.on('error', (error) => {\n        reject(error)\n      })\n    })\n\n    let fuzzyHeader: string[] | undefined\n    let fuzzySkip: number | undefined\n    // check if any rows after the header fuzzy match with the\n    // chosen header, indicating it's a sub header\n    for (let i = skip; i < rows.length; i++) {\n      const row = rows[i]\n      if (countNonEmptyCells(header) === countNonEmptyCells(row)) {\n        const fuzzyMatches = header.filter((cell, index) => {\n          const rowCell = row[index]?.trim() ?? ''\n          return rowCell\n            .split(/\\s+/)\n            .every((word) => cell.toLowerCase().includes(word.toLowerCase()))\n        })\n\n        if (fuzzyMatches.length / header.length > 0.5) {\n          fuzzyHeader = row\n          fuzzySkip = i + 1\n          letters = headersToLetters(fuzzyHeader)\n        }\n      }\n    }\n\n    return { header: fuzzyHeader ?? header, skip: fuzzySkip ?? skip, letters }\n  }\n}\n","export function prependNonUniqueHeaderColumns(\n  record: Record<string, string>\n): Record<string, string> {\n  const counts: Record<string, number> = {}\n  const result: Record<string, string> = {}\n\n  for (const [key, value] of Object.entries(record)) {\n    const newValue = value ? value : 'empty'\n    const cleanValue =\n      typeof newValue === 'string' ? newValue.replace('*', '') : newValue\n\n    if (cleanValue && counts[cleanValue]) {\n      result[key] = `${cleanValue}_${counts[cleanValue]}`\n      counts[cleanValue]++\n    } else {\n      result[key] = cleanValue\n      counts[cleanValue] = 1\n    }\n  }\n\n  return result\n}\n","import { SheetCapture, WorkbookCapture } from '@flatfile/util-extractor'\nimport { mapKeys, mapValues } from 'remeda'\nimport { Readable } from 'stream'\nimport * as XLSX from 'xlsx'\nimport { ExcelExtractorOptions } from '.'\nimport { GetHeadersOptions, Headerizer } from './header.detection'\nimport { prependNonUniqueHeaderColumns } from './utils'\n\ntype ParseBufferOptions = Omit<\n  ExcelExtractorOptions,\n  'chunkSize' | 'parallel'\n> & { readonly headerSelectionEnabled?: boolean }\ntype ProcessedSheet = [PropertyKey, SheetCapture]\n\nexport async function parseBuffer(\n  buffer: Buffer,\n  options?: ParseBufferOptions\n): Promise<WorkbookCapture> {\n  let workbook: XLSX.WorkBook\n  try {\n    workbook = XLSX.read(buffer, {\n      type: 'buffer',\n      cellDates: true,\n      dense: true,\n      dateNF: options?.dateNF || undefined,\n      // SheetJS intends the 'WTF' option to be used for development purposes only.\n      // We use it here to specifically capture the ERR_STRING_TOO_LONG error.\n      WTF: true,\n    })\n  } catch (e) {\n    // catch the error if the file is too large to parse, and throw a more helpful error.\n    // ref: https://docs.sheetjs.com/docs/miscellany/errors/#invalid-string-length-or-err_string_too_long\n    // i.e. 'Cannot create a string longer than 0x1fffffe8 characters'\n    if (e.code === 'ERR_STRING_TOO_LONG') {\n      if (options?.debug) {\n        console.log(\n          'File is too large to parse. Try converting this file to CSV.'\n        )\n      }\n      throw new Error(\n        'File is too large to parse. Try converting this file to CSV.'\n      )\n    }\n\n    // Try reading the file again without the 'WTF' option.\n    workbook = XLSX.read(buffer, {\n      type: 'buffer',\n      cellDates: true,\n      dense: true,\n      dateNF: options?.dateNF || undefined,\n    })\n  }\n\n  const sheetNames = Object.keys(workbook.Sheets)\n  try {\n    const processedSheets = (\n      await Promise.all(\n        sheetNames.map(async (sheetName) => {\n          const sheet = workbook.Sheets[sheetName]\n          const processedSheet = await convertSheet({\n            sheet,\n            sheetName,\n            rawNumbers: options?.rawNumbers || false,\n            raw: options?.raw || false,\n            headerDetectionOptions: options?.headerDetectionOptions || {\n              algorithm: 'default',\n            },\n            headerSelectionEnabled: options?.headerSelectionEnabled ?? false,\n            skipEmptyLines: options?.skipEmptyLines ?? false,\n            debug: options?.debug,\n          })\n          if (!processedSheet) {\n            return\n          }\n          return [sheetName, processedSheet]\n        })\n      )\n    ).filter(Boolean) as ProcessedSheet[]\n    return Object.fromEntries(processedSheets)\n  } catch (e) {\n    console.error(e)\n    throw new Error('Failed to parse workbook')\n  }\n}\n\ntype ConvertSheetArgs = {\n  sheet: XLSX.WorkSheet\n  sheetName: string\n  rawNumbers: boolean\n  raw: boolean\n  headerDetectionOptions: GetHeadersOptions\n  headerSelectionEnabled: boolean\n  skipEmptyLines: boolean\n  debug?: boolean\n}\n\n/**\n * Convert a template sheet using a special template format\n *\n * @param sheet\n */\nasync function convertSheet({\n  sheet,\n  sheetName,\n  rawNumbers,\n  raw,\n  headerDetectionOptions,\n  headerSelectionEnabled,\n  skipEmptyLines,\n  debug,\n}: ConvertSheetArgs): Promise<SheetCapture | undefined> {\n  let rows = XLSX.utils.sheet_to_json<Record<string, any>>(sheet, {\n    header: 'A',\n    defval: null,\n    rawNumbers,\n    raw,\n    blankrows: headerSelectionEnabled || !skipEmptyLines,\n  })\n\n  // return if there are no rows\n  if (!rows || rows.length === 0) {\n    if (debug) {\n      console.log(`No rows found in '${sheetName}'`)\n    }\n    return\n  }\n\n  const extractValues = (data: Record<string, any>[]) =>\n    data.map((row) => Object.values(row))\n\n  const headerizer = Headerizer.create(headerDetectionOptions)\n  const headerStream = Readable.from(extractValues(rows))\n  const { skip, header } = await headerizer.getHeaders(headerStream)\n  const headerKey = Math.max(0, skip - 1)\n  const columnKeys = Object.keys(rows[headerKey])\n\n  if (debug) {\n    console.log('Detected header:', header)\n  }\n\n  if (!headerSelectionEnabled) rows.splice(0, skip)\n\n  // return if there are no rows\n  if (rows.length === 0) {\n    if (debug) {\n      console.log(`No rows found in '${sheetName}'`)\n    }\n    return\n  }\n\n  const toExcelHeader = (data: string[], keys: string[]) =>\n    data.reduce((result, value, index) => {\n      result[keys[index]] = value\n      return result\n    }, {})\n  const columnHeaders = headerSelectionEnabled ? columnKeys : header\n  const excelHeader = toExcelHeader(columnHeaders, columnKeys)\n  const headers = prependNonUniqueHeaderColumns(excelHeader)\n\n  while (\n    rows.length > 0 &&\n    Object.values(rows[rows.length - 1]).every(isNullOrWhitespace)\n  ) {\n    rows.pop()\n  }\n\n  const data = rows.map((row) =>\n    mapValues(\n      mapKeys(row, (key) => headers[key as keyof typeof headers]),\n      (value) => ({ value })\n    )\n  )\n  let metadata: { rowHeaders: number[] } | undefined = undefined\n  if (headerSelectionEnabled) {\n    metadata = {\n      rowHeaders: [skip],\n    }\n  }\n\n  return {\n    headers: Object.values(headers).filter(Boolean),\n    data,\n    metadata,\n  }\n}\n\nconst isNullOrWhitespace = (value: any) =>\n  value === null || (typeof value === 'string' && value.trim() === '')\n","import { Extractor } from '@flatfile/util-extractor'\nimport { GetHeadersOptions } from './header.detection'\nimport { parseBuffer } from './parser'\n\n/**\n * Plugin config options.\n *\n * @property {boolean} raw - if true, return raw data; if false, return formatted text.\n * @property {boolean} rawNumbers - if true, return raw numbers; if false, return formatted numbers.\n * @property {string} dateNF - the date format.\n * @property {number} chunkSize - the size of chunk to process when inserting records.\n * @property {number} parallel - the quantity of parallel process when inserting records.\n * @property {GetHeadersOptions} headerDetectionOptions - the options for header detection.\n * @property {boolean} skipEmptyLines - if true, skip empty lines; if false, include empty lines.\n * @property {boolean} debug - if true, display helpful console logs.\n */\nexport interface ExcelExtractorOptions {\n  readonly raw?: boolean\n  readonly rawNumbers?: boolean\n  readonly dateNF?: string\n  readonly headerDetectionOptions?: GetHeadersOptions\n  readonly skipEmptyLines?: boolean\n  readonly chunkSize?: number\n  readonly parallel?: number\n  readonly debug?: boolean\n}\n\nexport const ExcelExtractor = (options?: ExcelExtractorOptions) => {\n  return Extractor(\n    /\\.(xlsx?|xlsm|xlsb|xltx?|xltm)$/i,\n    'excel',\n    parseBuffer,\n    options\n  )\n}\n\nexport const excelParser = parseBuffer\n\n/*\n * @deprecated use `ExcelExtractor` instead\n */\nexport const xlsxExtractorPlugin = ExcelExtractor\n"]}