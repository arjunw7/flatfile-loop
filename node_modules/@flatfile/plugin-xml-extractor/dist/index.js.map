{"mappings":";;;;;;;;;;;;;;;;;;ACIO,SAAS,0CACd,MAAc,EACd,OAIC;IAED,MAAM,YAAY,SAAS,aAAc,CAAA,CAAC,QAAU,KAAI;IACxD,MAAM,OAAO,0CAAU,OAAO,QAAQ;IACtC,MAAM,UAAU,0CAAsB;IAEtC,MAAM,YAAY;IAClB,OAAO;QACL,CAAC,UAAU,EAAE;qBACX;YACA,MAAM,KAAK,GAAG,CAAC,CAAC;gBACd,OAAO,CAAA,GAAA,uBAAQ,EAAE,UAAU,MAAM,CAAC,QAAW,CAAA;+BAAE;oBAAM,CAAA;YACvD;QACF;IACF;AACF;AAEO,SAAS,0CACd,GAA0B;IAE1B,OAAO,IAAI,GAAG,CAAC,CAAC;QACd,OAAO,gCAAU,KAAK,CAAC,GAAG,QAAU;gBAAC;gBAAG;2BAAE;gBAAM;aAAE;IACpD;AACF;AAEO,SAAS,0CAAU,GAAW;IACnC,MAAM,OAAO,0CAAS,CAAA,GAAA,8CAAK,EAAE;IAC7B,OAAO,KAAK,GAAG,CAAC,CAAC,MAAQ,oCAAc;AACzC;AAEO,SAAS,0CACd,GAA+B;IAE/B,MAAM,OAA6B,CAAC;IACpC,IAAI,OAAO,CAAC,CAAC;QACX,OAAO,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC;YACxB,IAAI,CAAC,IAAI,GAAG;QACd;IACF;IACA,OAAO,OAAO,IAAI,CAAC;AACrB;AAEA,SAAS,wCAAkB,GAAwB;IACjD,IAAI,OAAO,iBAAiB,KAAK;QAC/B,MAAM,aAAa,gCAAU,IAAI,WAAW,EAAE,CAAC,GAAG,IAAM;gBAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBAAE;aAAE;QACpE,OAAO,IAAI,WAAW;QACtB,OAAO;YAAE,GAAG,GAAG;YAAE,GAAG,UAAU;QAAC;IACjC;IACA,OAAO;AACT;AAEA,SAAS,gCACP,GAAwB,EACxB,EAAwC;IAExC,MAAM,SAA8B,CAAC;IACrC,OAAO,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC;QACxB,MAAM,CAAC,KAAK,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE;QACjC,MAAM,CAAC,IAAI,GAAG;IAChB;IACA,OAAO;AACT;AAEA,SAAS,oCACP,KAA0B,EAC1B,SAAS,EAAE;IAEX,MAAM,MAAM,wCAAkB;IAC9B,IAAI,CAAC,KAAK,OAAO,CAAC;IAClB,MAAM,SAA8B,CAAC;IACrC,OAAO,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC;QACxB,MAAM,MAAM,SACR,SAAU,CAAA,EAAE,UAAU,CAAC,QAAQ,MAAM,UAAU,KAAK,GAAE,IACtD;QACJ,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,UACpB,OAAO,MAAM,CAAC,QAAQ,oCAAc,GAAG,CAAC,EAAE,EAAE,MAAM;aAElD,MAAM,CAAC,MAAO,CAAA,MAAM,WAAW,MAAM,KAAK,CAAA,EAAG,GAAG,GAAG,CAAC,EAAE;IAE1D;IACA,OAAO;AACT;AAEO,SAAS,0CAAS,IAAyB;IAChD,MAAM,MAAM,OAAO,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,IAAM,MAAM;IAChD,IAAI,CAAC,KACH,MAAM,IAAI,MAAM;IAElB,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,GAAG;QAAC,IAAI,CAAC,IAAI;KAAC;AAC3D;;;ADhGO,MAAM,4CAAe,CAAC;IAQ3B,OAAO,CAAA,GAAA,sCAAQ,EAAE,QAAQ,OAAO,CAAA,GAAA,yCAAU,GAAG;AAC/C;AAEO,MAAM,4CAAY,CAAA,GAAA,yCAAU","sources":["plugins/xml-extractor/src/index.ts","plugins/xml-extractor/src/parser.ts"],"sourcesContent":["import { Extractor } from '@flatfile/util-extractor'\nimport { parseBuffer } from './parser'\n\nexport const XMLExtractor = (options?: {\n  separator?: string\n  attributePrefix?: string\n  transform?: (row: Record<string, any>) => Record<string, any>\n  chunkSize?: number\n  parallel?: number\n  debug?: boolean\n}) => {\n  return Extractor('.xml', 'xml', parseBuffer, options)\n}\n\nexport const xmlParser = parseBuffer\n","import { WorkbookCapture } from '@flatfile/util-extractor'\nimport { mapValues } from 'remeda'\nimport toJSON from 'xml-json-format'\n\nexport function parseBuffer(\n  buffer: Buffer,\n  options?: {\n    separator?: string\n    attributePrefix?: string\n    transform?: (row: Record<string, any>) => Record<string, any>\n  }\n): WorkbookCapture {\n  const transform = options?.transform || ((value) => value)\n  const data = xmlToJson(buffer.toString())\n  const headers = headersFromObjectList(data)\n\n  const sheetName = 'Sheet1'\n  return {\n    [sheetName]: {\n      headers,\n      data: data.map((row) => {\n        return mapValues(transform(row), (value) => ({ value }))\n      }),\n    },\n  } as WorkbookCapture\n}\n\nexport function flatToValues(\n  obj: Record<string, any>[]\n): Array<Record<string, { value: any }>> {\n  return obj.map((obj) => {\n    return mapObject(obj, (k, value) => [k, { value }])\n  })\n}\n\nexport function xmlToJson(xml: string): Array<Record<string, any>> {\n  const json = findRoot(toJSON(xml))\n  return json.map((obj) => flattenObject(obj))\n}\n\nexport function headersFromObjectList(\n  arr: Array<Record<string, any>>\n): Array<string> {\n  const keys: Record<string, true> = {}\n  arr.forEach((obj) => {\n    Object.keys(obj).forEach((key) => {\n      keys[key] = true\n    })\n  })\n  return Object.keys(keys)\n}\n\nfunction flattenAttributes(obj: Record<string, any>): Record<string, any> {\n  if (obj && '_attributes' in obj) {\n    const attributes = mapObject(obj._attributes, (k, v) => [`#${k}`, v])\n    delete obj._attributes\n    return { ...obj, ...attributes }\n  }\n  return obj\n}\n\nfunction mapObject(\n  obj: Record<string, any>,\n  fn: (k: string, v: any) => [string, any]\n): Record<string, any> {\n  const result: Record<string, any> = {}\n  Object.keys(obj).forEach((k) => {\n    const [key, value] = fn(k, obj[k])\n    result[key] = value\n  })\n  return result\n}\n\nfunction flattenObject(\n  input: Record<string, any>,\n  prefix = ''\n): Record<string, any> {\n  const obj = flattenAttributes(input)\n  if (!obj) return {}\n  const result: Record<string, any> = {}\n  Object.keys(obj).forEach((k) => {\n    const pre = prefix\n      ? prefix + (k.startsWith('#') || k === '_text' ? '' : '/')\n      : ''\n    if (typeof obj[k] === 'object') {\n      Object.assign(result, flattenObject(obj[k], pre + k))\n    } else {\n      result[pre + (k === '_text' && pre ? '' : k)] = obj[k]\n    }\n  })\n  return result\n}\n\nexport function findRoot(json: Record<string, any>): Array<any> {\n  const key = Object.keys(json).find((k) => k !== '_declaration')\n  if (!key) {\n    throw new Error('No root xml object found')\n  }\n  return Array.isArray(json[key]) ? json[key] : [json[key]]\n}\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../../../"}